head	1.9;
access;
symbols;
locks
	GongCun:1.9; strict;
comment	@ * @;


1.9
date	2017.03.27.14.29.01;	author GongCun;	state Exp;
branches;
next	1.8;

1.8
date	2015.04.25.11.56.33;	author gongcunjust;	state Exp;
branches;
next	1.7;

1.7
date	2015.04.25.03.27.54;	author gongcunjust;	state Exp;
branches;
next	1.6;

1.6
date	2015.04.24.12.33.09;	author gongcunjust;	state Exp;
branches;
next	1.5;

1.5
date	2015.04.23.23.46.10;	author gongcunjust;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	2015.04.23.22.25.57;	author gongcunjust;	state Exp;
branches;
next	1.3;

1.3
date	2015.04.23.12.25.47;	author gongcunjust;	state Exp;
branches;
next	1.2;

1.2
date	2015.04.23.12.18.12;	author gongcunjust;	state Exp;
branches;
next	1.1;

1.1
date	2015.04.22.00.48.55;	author gongcunjust;	state Exp;
branches;
next	;

1.5.1.1
date	2015.04.25.03.18.23;	author gongcunjust;	state Exp;
branches;
next	;


desc
@@


1.9
log
@*** empty log message ***
@
text
@/*
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015,2016,2017 Cun Gong <gong_cun@@bocmacau.com>
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
#include "tpty.h"

void do_driver (int (*f_driver)(void))
{
	int		pipe[2];
	pid_t		child;

	/*
	 * create a stream pipe to communication with the driver.
	 */
	if (s_pipe(pipe) < 0)
		err_sys("can't create stream pipe");

	if ((child = fork()) < 0) {
		err_sys("fork error");
	} else if (child == 0) {/* child */
		int		ret;
		close(pipe[1]);

		/* stdin for driver */
		if (dup2(pipe[0], STDIN_FILENO) != STDIN_FILENO)
			err_sys("dup2 error to stdin");

		/* stdout for driver */
		if (dup2(pipe[0], STDOUT_FILENO) != STDOUT_FILENO)
			err_sys("dup2 error to stdout");
		if (pipe[0] != STDIN_FILENO && pipe[1] != STDOUT_FILENO)
			close(pipe[0]);

		/* leave stderr for driver alone */
		if (f_driver == (int (*)(void))0) {
			if (driver)
				execlp(driver, driver, (char *)0);
			else
				errno = EINVAL;
			err_sys("execlp error for: %s", driver);
		} else {
			ret = (*f_driver) ();
			exit(ret);
		}
	}
	close(pipe[0]);		/* parent */
	if (dup2(pipe[1], STDIN_FILENO) != STDIN_FILENO)
		err_sys("dup2 error to stdin");
	if (dup2(pipe[1], STDOUT_FILENO) != STDOUT_FILENO)
		err_sys("dup2 error to stdout");
	if (pipe[1] != STDIN_FILENO && pipe[1] != STDOUT_FILENO)
		close(pipe[1]);

	/*
	 * parent returns, but with stdin and stdout connected to the driver.
	 */
}
@


1.8
log
@remove the signal handler of SIGCHLD.
@
text
@d1 24
d27 1
a27 2
void
do_driver(int (*f_driver) (void), int isinter)
d29 2
a30 2
	int             pipe[2];
    pid_t           child;
d33 1
a33 1
	 * create a stream pipe to communication with the driver. 
d41 1
a41 1
		int             ret;
d55 5
a59 2
		if (driver && !isinter) {
			execlp(driver, driver, (char *) 0);
d75 1
a75 1
	 * parent returns, but with stdin and stdout connected to the driver. 
@


1.7
log
@change waitpid grom non-block mode to block mode.
@
text
@a2 5
static void
sig_chld(int);

pid_t           child;

d7 1
a39 2
	if (signal(SIGCHLD, sig_chld) == SIG_ERR)
		err_sys("signal SIGCHLD error");
a51 21

static void
sig_chld(int signo)
{
	int             status;

#if 0
#ifdef AIX
	if (signal(SIGCHLD, sig_chld) == SIG_ERR)
		err_sys("signal SIGCHLD error");
#endif
#endif

retry:
	if (waitpid(child, &status, 0) != child) { /* block mode */
        if (errno == EINTR)
            goto retry;
        err_sys("waitpid error");
    }
	exit(sys_exit(status));
}
@


1.6
log
@*** empty log message ***
@
text
@d61 1
a61 3
{				/* Actually it doesn't work if the parent not
				 * sleep to wait for the signal.  */
	pid_t           pid;
d71 6
a76 3
	while ((pid = waitpid((pid_t) - 1, &status, WNOHANG)) > 0)
		if (pid == child)
			break;
@


1.5
log
@kill(getpid(), SIGTERM).
@
text
@d76 1
a76 3
	if (sys_exit(status) != 0)
		if (kill(getpid(), SIGTERM) != 0)
			err_sys("kill failed");
@


1.5.1.1
log
@cancel the sig_chld handler but failed.
@
text
@d3 3
d44 2
d58 22
@


1.4
log
@change to do_driver(func, isinter).
@
text
@d76 2
a77 2
	if (sys_exit(status) == 100) /* timed out */
		if (kill(0, SIGTERM) != 0)
@


1.3
log
@release version.
@
text
@d9 1
a9 1
do_driver(int (*f_driver) (void))
d36 1
a36 1
		if (driver) {
@


1.2
log
@*** empty log message ***
@
text
@d9 1
a9 1
do_driver(int (*f_driver)(void))
d40 1
a40 1
			ret = (*f_driver)();
d66 1
d71 1
d76 3
a78 1
	exit(sys_exit(status));
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
do_driver(void)
d40 1
a40 1
			ret = def_driver();
@
