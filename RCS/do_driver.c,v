head	1.8;
access;
symbols;
locks
	gongcunjust:1.8; strict;
comment	@ * @;


1.8
date	2015.04.25.11.56.33;	author gongcunjust;	state Exp;
branches;
next	1.7;

1.7
date	2015.04.25.03.27.54;	author gongcunjust;	state Exp;
branches;
next	1.6;

1.6
date	2015.04.24.12.33.09;	author gongcunjust;	state Exp;
branches;
next	1.5;

1.5
date	2015.04.23.23.46.10;	author gongcunjust;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	2015.04.23.22.25.57;	author gongcunjust;	state Exp;
branches;
next	1.3;

1.3
date	2015.04.23.12.25.47;	author gongcunjust;	state Exp;
branches;
next	1.2;

1.2
date	2015.04.23.12.18.12;	author gongcunjust;	state Exp;
branches;
next	1.1;

1.1
date	2015.04.22.00.48.55;	author gongcunjust;	state Exp;
branches;
next	;

1.5.1.1
date	2015.04.25.03.18.23;	author gongcunjust;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove the signal handler of SIGCHLD.
@
text
@#include "tpty.h"

void
do_driver(int (*f_driver) (void), int isinter)
{
	int             pipe[2];
    pid_t           child;

	/*
	 * create a stream pipe to communication with the driver. 
	 */
	if (s_pipe(pipe) < 0)
		err_sys("can't create stream pipe");

	if ((child = fork()) < 0) {
		err_sys("fork error");
	} else if (child == 0) {/* child */
		int             ret;
		close(pipe[1]);

		/* stdin for driver */
		if (dup2(pipe[0], STDIN_FILENO) != STDIN_FILENO)
			err_sys("dup2 error to stdin");

		/* stdout for driver */
		if (dup2(pipe[0], STDOUT_FILENO) != STDOUT_FILENO)
			err_sys("dup2 error to stdout");
		if (pipe[0] != STDIN_FILENO && pipe[1] != STDOUT_FILENO)
			close(pipe[0]);

		/* leave stderr for driver alone */
		if (driver && !isinter) {
			execlp(driver, driver, (char *) 0);
			err_sys("execlp error for: %s", driver);
		} else {
			ret = (*f_driver) ();
			exit(ret);
		}
	}
	close(pipe[0]);		/* parent */
	if (dup2(pipe[1], STDIN_FILENO) != STDIN_FILENO)
		err_sys("dup2 error to stdin");
	if (dup2(pipe[1], STDOUT_FILENO) != STDOUT_FILENO)
		err_sys("dup2 error to stdout");
	if (pipe[1] != STDIN_FILENO && pipe[1] != STDOUT_FILENO)
		close(pipe[1]);

	/*
	 * parent returns, but with stdin and stdout connected to the driver. 
	 */
}
@


1.7
log
@change waitpid grom non-block mode to block mode.
@
text
@a2 5
static void
sig_chld(int);

pid_t           child;

d7 1
a39 2
	if (signal(SIGCHLD, sig_chld) == SIG_ERR)
		err_sys("signal SIGCHLD error");
a51 21

static void
sig_chld(int signo)
{
	int             status;

#if 0
#ifdef AIX
	if (signal(SIGCHLD, sig_chld) == SIG_ERR)
		err_sys("signal SIGCHLD error");
#endif
#endif

retry:
	if (waitpid(child, &status, 0) != child) { /* block mode */
        if (errno == EINTR)
            goto retry;
        err_sys("waitpid error");
    }
	exit(sys_exit(status));
}
@


1.6
log
@*** empty log message ***
@
text
@d61 1
a61 3
{				/* Actually it doesn't work if the parent not
				 * sleep to wait for the signal.  */
	pid_t           pid;
d71 6
a76 3
	while ((pid = waitpid((pid_t) - 1, &status, WNOHANG)) > 0)
		if (pid == child)
			break;
@


1.5
log
@kill(getpid(), SIGTERM).
@
text
@d76 1
a76 3
	if (sys_exit(status) != 0)
		if (kill(getpid(), SIGTERM) != 0)
			err_sys("kill failed");
@


1.5.1.1
log
@cancel the sig_chld handler but failed.
@
text
@d3 3
d44 2
d58 22
@


1.4
log
@change to do_driver(func, isinter).
@
text
@d76 2
a77 2
	if (sys_exit(status) == 100) /* timed out */
		if (kill(0, SIGTERM) != 0)
@


1.3
log
@release version.
@
text
@d9 1
a9 1
do_driver(int (*f_driver) (void))
d36 1
a36 1
		if (driver) {
@


1.2
log
@*** empty log message ***
@
text
@d9 1
a9 1
do_driver(int (*f_driver)(void))
d40 1
a40 1
			ret = (*f_driver)();
d66 1
d71 1
d76 3
a78 1
	exit(sys_exit(status));
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
do_driver(void)
d40 1
a40 1
			ret = def_driver();
@
