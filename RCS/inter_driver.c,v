head	1.4;
access;
symbols;
locks
	gongcunjust:1.4; strict;
comment	@ * @;


1.4
date	2015.04.23.12.25.27;	author gongcunjust;	state Exp;
branches;
next	1.3;

1.3
date	2015.04.22.03.35.38;	author gongcunjust;	state Exp;
branches;
next	1.2;

1.2
date	2015.04.22.03.33.31;	author gongcunjust;	state Exp;
branches;
next	1.1;

1.1
date	2015.04.22.00.32.00;	author gongcunjust;	state Exp;
branches;
next	;


desc
@initial version, copy from def_driver.c.
@


1.4
log
@release version.
@
text
@#include "tpty.h"
#include <signal.h>
#include <setjmp.h>

#define INTER_EOF 0
#define INTER_TIMEOUT 1
#define INTER_ERR 2

int
inter_driver(void)
{
	int             fd, len, ret, return_val = INTER_ERR, maxfd;
	char            readin[BUFSIZ];
	fd_set          rset;
#define return_inter_driver(x) {return_val = x; goto over;}

	if (signal(SIGHUP, SIG_IGN) == SIG_ERR)
		err_sys("SIGHUP");
	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		err_sys("SIGPIPE");

	fd = open("/dev/tty", O_RDONLY, 0);
	if (fd < 0)
		err_sys("open /dev/tty error");
	/*
	 * The user's terminal is put into raw so that the connection is
	 * transparent. 
	 */
	if (tty_raw(fd) < 0)
		err_sys("tty_raw error");
	if (atexit(tty_atexit) < 0)
		err_sys("atexit error");
	maxfd = fd > STDIN_FILENO ? fd : STDIN_FILENO;

	if (tty < 0)		/* original STDOUT_FILENO */
		err_quit("tty error");

	for (;;) {
		FD_ZERO(&rset);
		FD_SET(STDIN_FILENO, &rset);
		FD_SET(fd, &rset);

		ret = select(maxfd + 1, &rset, NULL, NULL, (struct timeval *) 0);
		if (ret < 0) {
			if (errno == EINTR)
				continue;
			return_inter_driver(INTER_ERR);
		} else if (!ret) {
			return_inter_driver(INTER_TIMEOUT);
		}
		if (FD_ISSET(STDIN_FILENO, &rset)) {
			len = read(STDIN_FILENO, readin, sizeof(readin));
			if (len <= 0)
				return_inter_driver(INTER_EOF);
			if (writen(tty, readin, len) != len)
				return_inter_driver(INTER_ERR);
		}
		if (FD_ISSET(fd, &rset)) {
			len = read(fd, readin, sizeof(readin));
			if (len <= 0)
				return_inter_driver(INTER_EOF);
			if (writen(STDOUT_FILENO, readin, len) != len)
				return_inter_driver(INTER_ERR);
		}
	}

over:
	return return_val;
}
@


1.3
log
@*** empty log message ***
@
text
@d14 1
a14 1
    fd_set rset;
d23 11
a33 11
    if (fd < 0)
        err_sys("open /dev/tty error");
    /*
     * The user's terminal is put into raw so that the
     * connection is transparent.
     */
    if (tty_raw(fd) < 0)
        err_sys("tty_raw error");
    if (atexit(tty_atexit) < 0)
        err_sys("atexit error");
    maxfd = fd > STDIN_FILENO ? fd : STDIN_FILENO;
d35 1
a35 1
	if (tty < 0) /* original STDOUT_FILENO */
d39 26
a64 27
        FD_ZERO(&rset);
        FD_SET(STDIN_FILENO, &rset);
        FD_SET(fd, &rset);

        ret = select(maxfd + 1, &rset, NULL, NULL, (struct timeval *)0);
        if (ret < 0) {
            if (errno == EINTR)
                continue;
            return_inter_driver(INTER_ERR);
        } else if (!ret) {
            return_inter_driver(INTER_TIMEOUT);
        }
        if (FD_ISSET(STDIN_FILENO, &rset)) {
            len = read(STDIN_FILENO, readin, sizeof(readin));
            if (len <= 0)
                return_inter_driver(INTER_EOF);
            if (writen(tty, readin, len) != len)
                return_inter_driver(INTER_ERR);
        }
        if (FD_ISSET(fd, &rset)) {
            len = read(fd, readin, sizeof(readin));
            if (len <= 0)
                return_inter_driver(INTER_EOF);
            if (writen(STDOUT_FILENO, readin, len) != len)
                return_inter_driver(INTER_ERR);
        }
        
@


1.2
log
@allow user to take control the keyboard, read from /dev/tty,
write to the original tty.
@
text
@d45 1
a45 1
            if (errno = EINTR)
@


1.1
log
@Initial revision
@
text
@d5 3
a7 22
#define EXP_EOF 0
#define EXP_TIMEOUT 1
#define EXP_ERRNO 2

static struct f {
	int             disable;
	int             repeat;
	int             nonr;
	char            prompt[BUFSIZ];
	char            cmd[BUFSIZ];
}               exp_list[EXP_FULL];

int             i_read_errno;

static int
match_readin(char *, char *);

static int
i_read(int, int, char *, int);

static void
fp2f(FILE * fp, int *p);
d10 1
a10 1
def_driver(void)
d12 4
a15 16
	FILE           *fp;
	int             i, n, cc;
	int             zero;
	char           *readin;
	int             len, return_val = EXP_ERRNO;
	int             ret, buf_len, readin_len;
	char           *readin_end, *match_end;
#define return_def_driver(x) {return_val = x; goto cleanup;}

	readin_len = 2 * BUFSIZ;
	if ((readin = calloc(readin_len, 1)) == NULL)
		err_sys("calloc failed");

	match_end = readin;
	readin_end = readin;
	buf_len = 0;
d22 12
a33 3
	fp = fopen(pathconfig, "r");
	if (fp == NULL)
		err_sys("fopen config");
d35 2
a36 1
	fp2f(fp, &n);
a37 10
	if (tty < 0)
		err_quit("tty error");
	if (zeroflg) {
		if ((zero = open("/dev/null", O_RDWR)) < 0)
			err_sys("open /dev/null");
		if (dup2(zero, tty) != tty)
			err_sys("dup2 error to tty");
		if (zero != tty)
			close(zero);
	}
d39 27
a65 43
		cc = i_read(tty, timeout, readin_end, readin_len - 1 - buf_len);

		if (cc == EOF)
			return_def_driver(EXP_EOF);
		if (cc == -2) {
			if (i_read_errno == EIO)
				return_def_driver(EXP_EOF);
			errno = i_read_errno;
			err_sys("select error");
		}
		if (cc == -3)
			return_def_driver(EXP_TIMEOUT);

		buf_len += cc;
		readin_end = readin + buf_len;
		*readin_end = '\0';

		for (i = 0; i < n; i++) {
			if (!exp_list[i].disable &&
			 (ret = match_readin(readin, exp_list[i].prompt))) {
				match_end = readin + ret;
				buf_len = readin_end - match_end;
				memmove(readin, match_end, buf_len);
				readin_end = readin + buf_len;

				if (!exp_list[i].repeat)
					exp_list[i].disable = 1;
				if (strstr(exp_list[i].cmd, "<INTERACT>") != NULL && manflg)
					return_def_driver(EXP_EOF);
				len = strlen(exp_list[i].cmd);
				if (writen(STDOUT_FILENO, exp_list[i].cmd, len) != len)
					if (errno != EPIPE && errno != EIO)
						err_sys("writen error");
				break;
			}
		}

		/* move last half to first half */
		if (buf_len == readin_len - 1) {
			memmove(readin, readin + buf_len / 2, readin_len - 1 - buf_len / 2);
			buf_len = readin_len - 1 - buf_len / 2;
			readin_end = readin + buf_len;
		}
d68 1
a68 8
cleanup:
	fclose(fp);
	free(readin);

	if (manflg == 0)
		if (write(tty, "\n", 1) != 1)
			err_sys("write tty");

a70 128

int
match_readin(char *readin, char *str)
{				/* return the end position of the match
				 * string */
	int             ret;
	char           *ch;

	ch = strstr(readin, str);
	if (ch != NULL)
		return ch - readin + strlen(str);
	if ((ret = strregex(str, readin)) > 0)
		return ret;
	return 0;

}

static int
i_read(int fd, int tm, char *buf, int buf_size)
{
	fd_set          rset;
	int             cc, ret;
	struct timeval  tv, *tvptr;

	if (tm < 0)
		tvptr = (struct timeval *) 0;
	else {
		tv.tv_sec = tm;
		tv.tv_usec = 0;
		tvptr = &tv;
	}

start:
	FD_ZERO(&rset);
	FD_SET(STDIN_FILENO, &rset);

	if ((ret = select(STDIN_FILENO + 1, &rset, NULL, NULL, tvptr)) < 0) {
		if (errno == EINTR)
			goto start;
		i_read_errno = errno;
		return -2;
	}
	if (ret == 0) {		/* timeout */
		return -3;
	}
	if (FD_ISSET(STDIN_FILENO, &rset)) {
		cc = read(STDIN_FILENO, buf, buf_size);
		if (cc < 0)
			err_sys("read error");
		if (cc == 0)
			return EOF;	/* EOF == -1 */
		if (cc > 0) {
			if (writen(fd, buf, cc) != cc)
				if (errno != EIO)
					err_sys("writen error");
		}
	}
	return cc;
}

static void
fp2f(FILE * fp, int *p)
{
	char           *buf, *ptr, ch;
	int             i, loop, len, offset;
	char            encrypted[4098];

	buf = malloc(2 * BUFSIZ);
	if (buf == NULL)
		err_sys("malloc failed");
	for (i = 0;; i++) {
		loop = 0;
		if (i >= EXP_FULL)
			err_quit("lines out of scope");
		if (fgets(buf, 2 * BUFSIZ, fp) == NULL) {
			if (feof(fp))
				break;
			if (ferror(fp))
				err_sys("fgets error");
		}
		if (strtok(buf, DELIM) == NULL)
			err_quit("format error: line %d.", i + 1);
		if (strlen(buf) > BUFSIZ - 1)
			err_quit("prompt string out of buffer: line %d.", i + 1);
		strcpy(exp_list[i].prompt, buf);
		exp_list[i].prompt[BUFSIZ - 1] = '\0';

		bzero(exp_list[i].cmd, sizeof exp_list[i].cmd);
		while ((ptr = strtok(NULL, DELIM)) != NULL) {
			if (strlen(ptr) > BUFSIZ - 3 - strlen(exp_list[i].cmd))	/* '%' + '\r' + null = 3 */
				err_quit("cmd string out of buff: line %d.", i + 1);
			if (strstr(ptr, "<REPEAT>") != NULL) {
				exp_list[i].repeat = 1;
			} else if (strstr(ptr, "<NONR>") != NULL) {
				exp_list[i].nonr = 1;
			} else if (strstr(ptr, "<ENCRYPT>") != NULL) {
				if (!(rsafd && keyfd))
					err_quit("cannot open key or rsa file");
				if (!fread(&offset, sizeof offset, 1, keyfd))	/* the encrypted key
										 * length */
					err_sys("fread offset error");
				len = fread(encrypted, 1, offset, keyfd);
				if (!len)
					err_sys("fread encrypted string error");
				private_decrypt(encrypted, len, rsafd, exp_list[i].cmd);
			} else {
				if (loop != 0)
					strcat(exp_list[i].cmd, "%");
				strcat(exp_list[i].cmd, ptr);
			}
			loop++;
		}

		if (strlen(exp_list[i].cmd) == 0) {
			strcpy(exp_list[i].cmd, "\r");
		} else {
			ch = exp_list[i].cmd[strlen(exp_list[i].cmd) - 1];
			if (ch != '\r' && !exp_list[i].nonr) {
				if (ch == '\n')
					exp_list[i].cmd[strlen(exp_list[i].cmd) - 1] = '\0';
				strcat(exp_list[i].cmd, "\r");
			}
		}
		exp_list[i].cmd[BUFSIZ - 1] = '\0';
	}
	*p = i;
	free(buf);
}
@
